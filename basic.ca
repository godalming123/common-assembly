print :: (arg str rsi, arg strLen rdx, mut mem1 rax, mut mem2 rdi) {
	# Since mem1 and mem2 are not args, they're input does not effect the result
	# of the function, and therefore the compiler forces that they cannot
	# be used as args until there value has been changed.
	mem1 = 1
	mem2 = 1
	# TODO: Instead of `syscall`, for the user to say `syscall mut str, mut strLen, mut mem1, mut mem2` so that every possible mutation is explicit
	syscall
}

main :: (mut mem1 rax, mut mem2 rdi, mut mem3 rsi, mut mem4 rdx) {
	mem3 = "Hello"
	mem4 = 5
	print mem3, mem4, mem1, mem2
	
	mem3 = "World!\n"
	mem4 = 7
	print mem3, mem4, mem1, mem2

	mem1 = 60 # sys_exit syscall
	mem2 = 5 # exit status
	mem3 = 3
	pow mut mem2, mut mem3 # mem2 -> 5 ^ 3 -> 125
	                       # mem3 -> 1
	syscall
}

# Calculates x^y. `x` is set to the result, and `y` is set to min(y, 1). Here
# x any y could occupy any register since the code does not specify.
pow :: (mut x, mutArg y) {
	while y > 1 {
		x *= x
		y--
	}
	# TODO: Support this updated code that uses the `loop` insruction in x86
	# assembly to be faster
	# if y <= 1 {
	# 	return
	# }
	# y--
	# do {
	# 	x *= x
	# } while decAndContinueIfNotZero mutArg y
	# The code above compiles to the following x86-64 assembly:
	# cmp ecx, 1
	# jle end ; If ecx <= 0, jump to end
	# dec ecx
	# loop:
	#     mul x, x
	#     ; Exactly like `dec ecx`, then `jnz loop`, except it doesn't set flags,
	#     ; and is faster
	#     loop loop
	# end:
}
