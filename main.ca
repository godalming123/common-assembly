print :: (mut mem1 rax, mut mem2 rdi, arg text rsi, arg textLen rdx) {
	mem1 = 1 # Write syscall
	mem2 = 1 # Stdout file descriptor
	syscall
}

main :: (mut mem1 rax, mut mem2 rdi, mut mem3 rsi, mut mem4 rdx, mut mem5 bl) {
	mem3 = "Hello world\n" # The text to be written
	mem4 = 12              # The number of charecters to be written
	print mut mem1, mut mem2, arg mem3, arg mem4
	
	mem5 = 0
	while 10 > mem5 {
		mem3 = "Counting to 10\n" # The text to be written
		mem4 = 15                 # The number of charecters to be written
		print mut mem1, mut mem2, arg mem3, arg mem4
		mem5++
	}
	return
}

pointIsOnScreen :: (mut mem1 rax, mut mem2 rdi, mut mem3 rsi, mut mem4 rdx, arg alwaysReturnTrue any, arg false1InsteadOf2 any, arg screenWidth any, arg screenHeight any, arg pointX any, arg pointY any) {
	# This is just to test the compilation of complex conditions
	# TODO: Add () to the order of operations for expressions so alwaysReturnTrue
	# is only referenced once
	if 0 <= pointX < screenWidth or alwaysReturnTrue != 0
    	and 0 <= pointY < screenHeight or alwaysReturnTrue != 0 {
		mem3 = "TRUE"
		mem4 = 4
		print arg mem3, arg mem4, mut mem1, mut mem2
	} elif false1InsteadOf2 != 0 {
		mem3 = "FALSE1"
		mem4 = 6
		print arg mem3, arg mem4, mut mem1, mut mem2
	} else {
		mem3 = "FALSE2"
		mem4 = 6
		print arg mem3, arg mem4, mut mem1, mut mem2
	}
	if pointX == pointY {
		mem3 = "The x is the same as the y"
		mem4 = 26
		print arg mem3, arg mem4, mut mem1, mut mem2
	}
}

# Calculates x^y. `x` is set to the result, and `y` is set to min(y, 1). Here
# x and y could occupy any register since the code does not specify.
pow :: (mut x any, mutArg y any) {
	while y > 1 {
		x *= x
		y--
	}
	# TODO: Support this updated code that uses the `loop` insruction in x86
	# assembly to be faster
	# if y <= 1 {
	# 	return
	# }
	# y--
	# do {
	# 	x *= x
	# } while decAndContinueIfNotZero mutArg y

	# The code above compiles to the following x86-64 assembly:
	# cmp ecx, 1
	# jle end ; If ecx <= 0, jump to end
	# dec ecx
	# loop:
	#     mul x, x
	#     ; Exactly like `dec ecx`, then `jnz loop`, except it doesn't set flags,
	#     ; and is faster
	#     loop loop
	# end:
}
